package hpl.comp;

import hpl.lang.*;
import hpl.values.*;
import hpl.sys.*;

import java.lang.*;
import java.lang.Integer;
import java.lang.String;
import java.lang.StringBuilder;
import java.lang.System;
import java.util.*;
import java.util.ArrayList;
import java.util.HashMap;

public class HPLToSVG implements HPLCompiler,HPLVisitor<HPLContext, CompilerResult>
{
    private String variable_start = "t";
    private int count =0;
    private ArithEvaluator arithEval;
    private LogicEvaluator logicEval;
    private Initialiser fResult = new Initialiser();
    private final PainterFrame screenFrame = new PainterFrame();
    private final Screen screen = new Screen(screenFrame, 400);

	/**
     * Translate the given AST into the appropriate target representation.  This
     * method should invoke the visitPIRProgram method of a visitor that
     * compiles its input program.  (This visitor may very well be this same
     * class that implements HPLCompiler, or one that is delegated to by it).  
     * Defining an HPLCompiler interface separately from the Visitor<S,T> 
     * interface allows the main entry point to invoke the compiler without
     * presuming any properties about the type of context (instance of S) 
     * required by the compiling Visitor instance.
     *
     * @param prog The HPLProgram to be compiled.
     * @return The object representing the translated program.
     */
    public CompilerResult translate(PIRProgram prog)
    {
        this.arithEval = new ArithEvaluator();
        this.logicEval = new LogicEvaluator();

        try
        {
            fResult.setPaintResult(prog.visit(this, new HPLContextManager(screenFrame, new HPLEnvironment<HPLFunction>(),
                    new HPLEnvironment<Double>(), new HPLEnvironment<Painter>(),new HPLEnvironment<CompilerResult>())));
        }
        catch (HPLException e)
        {
            System.out.print(e.toString());
            return null;
        }

        return fResult;

    }


    /**
     *
     * @return the file extension appropriate for saving code
     * generated by this compiler.
     */
    public String getTargetExtension()
    {
    	return ".svg";
    }

    @Override
    public CompilerResult visitPIRProgram(PIRProgram program, HPLContext env)
            throws HPLException {

        PIRSequence stmts = program.getSeq();
	   return stmts.visit(this, env);
    }

    @Override
    public CompilerResult visitPIRAssignment(PIRAssignment assignment,
                                             HPLContext context) throws HPLException {
        CompilerResult result = assignment.getExp().visit(this, context);
        context.putC(assignment.getVar(), result);
        return new CompilerResult(){
            @java.lang.Override
            public String gen()
            {
                return "";
            }
        };
    }

    @Override
    public CompilerResult visitPIRSequence(PIRSequence seq, HPLContext env)
	throws HPLException
    {
        ArrayList<PIRStatement> stmts = seq.getStatements();
        SequenceResult sequenceResult = new SequenceResult();
        for (PIRStatement stmt : stmts) {
            sequenceResult.addResult(stmt.visit(this, env));
        }

        return sequenceResult;
    }

    @Override
    public CompilerResult visitPIRImagePainter(PIRImagePainter exp, HPLContext env)
	throws HPLException {
       return new ImagePainterResult(exp.getFile());
    }

    @Override
    public CompilerResult visitPIRFunDefinition(PIRFunDefinition funDefinition, HPLContext context) throws HPLException {
        String funName = funDefinition.getFunName();
        ArrayList<String> nArithParams = funDefinition.getParams(0);
        ArrayList<String> painterParams = funDefinition.getParams(1);
        PIRSequence body = funDefinition.getBody();

        HPLFunction function = new HPLFunction(funName, nArithParams, painterParams, body, context);
        context.putF(funName, function);
        return new CompilerResult(){
            @java.lang.Override
            public String gen()
            {
                return "";
            }
        };
    }

    @Override
    public CompilerResult visitPIRFunCall(PIRFunCall funCall, HPLContext context) throws HPLException {

        String funName = funCall.getFunName();
        ArrayList<ASTExp<AIRExp>> nArgExps = funCall.getNumericalArgExps();
        ArrayList<ASTExp<PIRExp>> pArgExps = funCall.getPainterArgExps();

        HPLFunction function = context.getF(funName);

        ArrayList<Double> args = new ArrayList<>();
        ArrayList<CompilerResult> pArgs = new ArrayList<>();

        PIRSequence body = function.getBody();

        // evaluate the argument parameters ...
        for(ASTExp<AIRExp> arg: nArgExps)
        {
            args.add(arg.visit(arithEval, context.getNumEnv()));

        }


        for(ASTExp<PIRExp> pArg: pArgExps)
        {
            pArgs.add(pArg.visit(this,context));
        }


        context = context.extendC(function.getPainterParams(), pArgs);

        // also extend with bindings for numerical parameters
        context = context.extendN(function.getNumericalParams(), args);

        // and we extend with empty function frame to keep local functions local
        context = context.extendF(new ArrayList<String>(), new ArrayList<HPLFunction>());

        FunCallResult finalResult = new FunCallResult();
        CompilerResult result = body.visit(this, context);
        finalResult.addContent(result);

        return finalResult;
    }


    public CompilerResult visitPIRConditionStmt(PIRConditionalStatement conditionStmt, HPLContext context) throws HPLException
    {
        ASTExp<LogicExp> logic = conditionStmt.getCondition();
        PIRSequence body1 = conditionStmt.getBody1();
        PIRSequence body2 = conditionStmt.getBody2();

        boolean result = logic.visit(logicEval,context);
        if(result)
        {
            return body1.visit(this, context);
        }
        else {
            if (body2 != null) {
                return body2.visit(this, context);
            }
            return new CompilerResult(){
                @java.lang.Override
                public String gen()
                {
                    return "";
                }
            };
        }
    }

    @Override
    public CompilerResult visitPIRPaintStmt(PIRPaintStmt paintStmt, HPLContext env)
	throws HPLException {

        PIRFrameExp frameExp = paintStmt.getFrameExp();
        ASTExp<PIRExp> painterExp = paintStmt.getPainterExp();

        PainterFrame frame = frameExp.eval(env);

        CompilerResult painterResult = painterExp.visit(this, env);

        PaintStmtResult result = new PaintStmtResult();
        result.buildPaintStmt(painterResult,frame);

        return result;
    }

    @Override
    public CompilerResult visitPIRWaitStmt(PIRWaitStmt waitStmt, HPLContext state) throws HPLException {
        return new CompilerResult(){
            @java.lang.Override
            public String gen()
            {
                return "";
            }
        };
    }

    @Override
    public CompilerResult visitVar(ASTVar<PIRExp> var, HPLContext context)
	throws HPLException {
        Declaration result = (Declaration) context.getC(var.getId());
        result.setId(var.getId());
       return result;
    }

    @Override
    public CompilerResult visitUnaryExp(ASTUnaryExp<PIRExp> var, HPLContext context)
    throws HPLException {
        return new CompilerResult(){
            @java.lang.Override
            public String gen()
            {
                return "";
            }
        };
    }

    @Override
    public CompilerResult visitBinaryExp(ASTBinaryExp<PIRExp> var, HPLContext context)
    throws HPLException {
        return new CompilerResult(){
            @java.lang.Override
            public String gen()
            {
                return "";
            }
        };
    }


}